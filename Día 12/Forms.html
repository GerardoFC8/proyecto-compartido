<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guía Completa de Laravel: Arrays, Fechas e Imágenes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .container {
            max-width: 1200px;
            margin: auto;
            padding: 20px;
        }
        h1, h2, h3 {
            font-weight: 700;
            color: #1a202c;
        }
        h1 { font-size: 2.25rem; }
        h2 { font-size: 1.875rem; margin-top: 2rem; border-bottom: 2px solid #e2e8f0; padding-bottom: 0.5rem; }
        h3 { font-size: 1.5rem; margin-top: 1.5rem; }
        p, li {
            font-size: 1.125rem;
            line-height: 1.75;
            color: #4a5568;
        }
        code {
            font-size: 0.9em;
        }
        pre[class*="language-"] {
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="bg-gray-50">

    <div class="container bg-white shadow-lg rounded-lg p-8 mt-10">

        <h1 class="text-4xl font-bold mb-4 text-center text-indigo-600">Laravel</h1>
        <p class="text-xl text-center text-gray-600 mb-8">Manejo avanzado de Arrays, Fechas e Imágenes Múltiples</p>
        
        <!-- SECCIÓN DE ARRAYS -->
        <h2 id="arrays">1. Manejo de Arrays en Laravel</h2>
        <p>Laravel hace que trabajar con arrays sea muy sencillo, especialmente con la ayuda de la propiedad <strong><code>$casts</code></strong> en los modelos de Eloquent. Esta propiedad le dice a Laravel que convierta automáticamente un atributo de la base de datos (generalmente almacenado como JSON) a un array de PHP cuando accedes a él, y viceversa.</p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">1.1. El Modelo `Post.php` y la Magia del Casting</h3>
        <p>En tu modelo <code>Post.php</code>, la sección <code>casts</code> es fundamental:</p>
        <pre><code class="language-php">
// App/Models/Post.php

protected function casts(): array
{
    return [
        'tags' => 'array',
        'meta_data' => 'collection', // 'collection' es como un array supercargado
        'gallery_images' => 'array',
        'author_info' => 'object',
    ];
}
        </code></pre>
        <p>Gracias a esto, nunca tendrás que usar <code>json_encode</code> o <code>json_decode</code> manualmente. Laravel lo hace por ti.</p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">1.2. Array Unidimensional: `tags`</h3>
        <p>Los tags se reciben como un string separado por comas y se guardan como un array.</p>
        
        <strong>Formulario (Vista Blade):</strong>
        <pre><code class="language-html">
&lt;!-- El usuario ingresa: "php, laravel, javascript" --&gt;
&lt;input type="text" name="tags" class="form-control" value="{{ old('tags', implode(', ', $post->tags ?? [])) }}"&gt;
        </code></pre>

        <strong>Validación (`PostStoreRequest.php`):</strong>
        <p>Simplemente validamos que sea un string, ya que lo procesaremos después.</p>
        <pre><code class="language-php">
'tags' => ['nullable', 'string'],
        </code></pre>

        <strong>Procesamiento (`PostController.php`):</strong>
        <p>En el método <code>handleComplexData</code>, convertimos el string en un array limpio.</p>
        <pre><code class="language-php">
// App/Http/Controllers/PostController.php -> handleComplexData()

if (!empty($data['tags'])) {
    // 1. explode: Convierte el string en array usando la coma.
    // 2. array_map: 'trim' a cada elemento para quitar espacios.
    // 3. array_filter: Elimina elementos vacíos si hay comas dobles (,,).
    $data['tags'] = array_filter(array_map('trim', explode(',', $data['tags'])));
} else {
    $data['tags'] = [];
}
        </code></pre>

        <strong>Renderizado en la Vista:</strong>
        <p>Recorremos el array para mostrar los tags.</p>
        <pre><code class="language-html">
&lt;div class="flex flex-wrap gap-2 mt-4"&gt;
    @forelse($post->tags as $tag)
        &lt;span class="bg-blue-100 text-blue-800 text-xs font-semibold mr-2 px-2.5 py-0.5 rounded"&gt;
            {{ $tag }}
        &lt;/span&gt;
    @empty
        &lt;p class="text-gray-500"&gt;No hay tags.&lt;/p&gt;
    @endforelse
&lt;/div&gt;
        </code></pre>

        <h3 class="text-2xl font-semibold mt-6 mb-3">1.3. Array de Objetos (Multidimensional): `meta_data`</h3>
        <p>Este es un caso más complejo, un array de pares clave-valor. Ideal para agregar datos dinámicos.</p>

        <strong>Formulario (Vista Blade con JavaScript):</strong>
        <p>Para esto, se necesita JavaScript para añadir y quitar campos dinámicamente.</p>
        <pre><code class="language-html">
&lt;!-- Input para el primer meta dato --&gt;
&lt;div class="meta-item"&gt;
    &lt;input type="text" name="meta_data[0][key]" placeholder="Clave"&gt;
    &lt;input type="text" name="meta_data[0][value]" placeholder="Valor"&gt;
&lt;/div&gt;
&lt;!-- Con JS se pueden añadir más: meta_data[1][key], etc. --&gt;
        </code></pre>

        <strong>Validación (`PostStoreRequest.php`):</strong>
        <p>El asterisco <code>*</code> es la clave. Valida cada elemento dentro del array <code>meta_data</code>.</p>
        <pre><code class="language-php">
'meta_data' => ['nullable', 'array'],
'meta_data.*.key' => ['nullable', 'string', 'max:255'],
'meta_data.*.value' => ['nullable', 'string', 'max:255'],
        </code></pre>

        <strong>Procesamiento (`PostController.php`):</strong>
        <p>Filtramos para quedarnos solo con los pares que tienen tanto clave como valor.</p>
        <pre><code class="language-php">
// App/Http/Controllers/PostController.php -> handleComplexData()

if (!empty($data['meta_data'])) {
    // Filtra los elementos donde 'key' o 'value' estén vacíos.
    $filteredMeta = array_filter($data['meta_data'], fn ($meta) => 
        !empty($meta['key']) && !empty($meta['value'])
    );
    // Re-indexa el array para evitar huecos (ej. 0, 2, 3).
    $data['meta_data'] = array_values($filteredMeta);
} else {
    $data['meta_data'] = [];
}
        </code></pre>

        <strong>Renderizado en la Vista:</strong>
        <p>Como <code>meta_data</code> se castea a una Colección de Laravel, podemos iterar sobre ella.</p>
        <pre><code class="language-html">
&lt;ul class="list-disc pl-5 mt-4"&gt;
    @foreach($post->meta_data as $meta)
        &lt;li&gt;&lt;strong&gt;{{ $meta['key'] }}:&lt;/strong&gt; {{ $meta['value'] }}&lt;/li&gt;
    @endforeach
&lt;/ul&gt;
        </code></pre>

        <!-- SECCIÓN DE IMÁGENES -->
        <h2 id="imagenes">2. Manejo de Múltiples Imágenes (`gallery_images`)</h2>
        <p>Subir una galería de imágenes implica tratar con un array de archivos.</p>

        <strong>Formulario (Vista Blade):</strong>
        <p>Los corchetes <code>[]</code> en el nombre del input y el atributo <code>multiple</code> son esenciales.</p>
        <pre><code class="language-html">
&lt;label for="gallery_images"&gt;Galería de Imágenes&lt;/label&gt;
&lt;input type="file" name="gallery_images[]" id="gallery_images" multiple&gt;
        </code></pre>

        <strong>Validación (`PostStoreRequest.php`):</strong>
        <p>Validamos que el campo sea un array, y que cada elemento <code>*</code> dentro de ese array sea una imagen válida.</p>
        <pre><code class="language-php">
'gallery_images' => ['nullable', 'array'],
'gallery_images.*' => ['image', 'mimes:jpeg,png,jpg,gif', 'max:2048'],
        </code></pre>

        <strong>Procesamiento (`PostController.php`):</strong>
        <p>Iteramos sobre cada archivo subido, lo guardamos y recolectamos las rutas.</p>
        <pre><code class="language-php">
// App/Http/Controllers/PostController.php -> handleComplexData()

// Obtenemos las imágenes existentes para no borrarlas al actualizar.
$galleryPaths = $post->gallery_images ?? []; 

if ($request->hasFile('gallery_images')) {
    foreach ($request->file('gallery_images') as $file) {
        $fileName = time() . '-' . Str::slug($file->getClientOriginalName()) . '.' . $file->getClientOriginalExtension();
        // storeAs devuelve la ruta donde se guardó el archivo.
        $galleryPaths[] = $file->storeAs('posts/gallery', $fileName, 'public');
    }
}
$data['gallery_images'] = $galleryPaths;
        </code></pre>

        <strong>Renderizado en la Vista:</strong>
        <p>Usamos el helper <code>asset()</code> para generar la URL pública correcta para cada imagen.</p>
        <pre><code class="language-html">
&lt;div class="grid grid-cols-3 gap-4 mt-4"&gt;
    @if($post->gallery_images)
        @foreach($post->gallery_images as $imagePath)
            &lt;div&gt;
                &lt;img src="{{ asset('storage/' . $imagePath) }}" alt="Imagen de galería" class="rounded-lg shadow-md"&gt;
            &lt;/div&gt;
        @endforeach
    @endif
&lt;/div&gt;
        </code></pre>
        
        <!-- SECCIÓN DE FECHAS -->
        <h2 id="fechas">3. Manejo de Fechas con Carbon</h2>
        <p>Laravel integra la librería Carbon, que hace que trabajar con fechas sea increíblemente fácil. El casting <code>'published_at' => 'datetime'</code> en tu modelo convierte automáticamente el campo en un objeto Carbon.</p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">3.1. Almacenamiento y Formato Personalizado</h3>
        <p>Puedes tener un campo de fecha manual en tu formulario.</p>
        <pre><code class="language-html">
&lt;label for="manual_created_at"&gt;Fecha de Creación Manual&lt;/label&gt;
&lt;input type="date" name="manual_created_at" id="manual_created_at" 
       value="{{ old('manual_created_at', $post->manual_created_at ? $post->manual_created_at->format('Y-m-d') : '') }}"&gt;
        </code></pre>
        <p>No importa el formato que envíes desde el formulario (<code>Y-m-d</code>, <code>d/m/Y</code>, etc.), mientras sea una fecha válida, Laravel y Carbon lo entenderán y lo guardarán en el formato estándar de tu base de datos (ej. <code>YYYY-MM-DD HH:MM:SS</code>).</p>

        <h3 class="text-2xl font-semibold mt-6 mb-3">3.2. Manejo de Fechas Nulas o Condicionales</h3>
        <p>En tu <code>PostController</code>, manejas inteligentemente el campo <code>published_at</code>: solo tiene un valor si el estado es 'published'. Esto es una excelente práctica para evitar fechas por defecto como '1970-01-01'.</p>

        <strong>Lógica en `PostController.php`:</strong>
        <pre><code class="language-php">
// App/Http/Controllers/PostController.php -> store() y update()

// Si el estado no es 'published', nos aseguramos que published_at sea null.
if ($data['status'] !== 'published') {
    $data['published_at'] = null;
}
        </code></pre>
        
        <strong>Renderizado en la Vista (Evitando errores):</strong>
        <p>Siempre comprueba si la fecha existe antes de intentar formatearla. De lo contrario, llamar a <code>format()</code> sobre <code>null</code> causará un error.</p>
        <pre><code class="language-html">
&lt;p&gt;
    &lt;strong&gt;Fecha de Publicación:&lt;/strong&gt;
    @if($post->published_at)
        {{-- Puedes usar cualquier formato que necesites --}}
        {{ $post->published_at->format('d/m/Y H:i A') }}
        
        &lt;!-- O formatos relativos, muy útiles --&gt;
        &lt;span class="text-gray-500"&gt;({{ $post->published_at->diffForHumans() }})&lt;/span&gt;
    @else
        &lt;span class="text-gray-500"&gt;Aún no publicado&lt;/span&gt;
    @endif
&lt;/p&gt;
        </code></pre>

        <h2 id="conclusion">Conclusión y Buenas Prácticas</h2>
        <ul class="list-disc pl-5 space-y-2 mt-4">
            <li><strong>Usa el Casting de Eloquent:</strong> Es la forma más limpia y mantenible de manejar atributos complejos como arrays, objetos o fechas.</li>
            <li><strong>Validación Específica:</strong> Aprovecha las reglas de validación con asteriscos (<code>meta_data.*.key</code>) para validar arrays de forma robusta.</li>
            <li><strong>Procesamiento en el Controlador:</strong> Mantén la lógica de transformación de datos (como el <code>explode</code> para tags) en el controlador, antes de crear o actualizar el modelo. El método <code>handleComplexData</code> es un gran ejemplo de esto.</li>
            <li><strong>Renderizado Seguro en Vistas:</strong> Siempre verifica si un dato (especialmente fechas o arrays) existe antes de intentar acceder a sus propiedades o recorrerlo para evitar errores en producción. Usa <code>@if</code>, <code>!empty()</code>, o <code>@forelse</code>.</li>
            <li><strong>Nombres de Inputs:</strong> Recuerda usar corchetes <code>[]</code> en los nombres de los inputs de formularios para arrays de datos o archivos múltiples.</li>
        </ul>

    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
